<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node Types Demo - Graph Editor</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f0f2f5;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    
    .header {
      padding: 20px;
      background: #1e40af;
      color: white;
    }
    
    .header h1 {
      margin: 0 0 10px 0;
      font-size: 24px;
    }
    
    .header p {
      margin: 0;
      opacity: 0.9;
      font-size: 14px;
    }
    
    .main-layout {
      display: flex;
      height: 700px;
    }
    
    .sidebar {
      width: 280px;
      background: #f8f9fa;
      border-right: 1px solid #e5e7eb;
      overflow-y: auto;
    }
    
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .toolbar {
      display: flex;
      gap: 10px;
      padding: 15px;
      background: #f8f9fa;
      border-bottom: 1px solid #e5e7eb;
      align-items: center;
    }
    
    .editor-container {
      flex: 1;
      position: relative;
      background: #fafafa;
    }
    
    /* Node Type Styles */
    .node-palette {
      padding: 15px;
    }
    
    .node-palette h3 {
      margin: 0 0 15px 0;
      font-size: 14px;
      text-transform: uppercase;
      color: #6b7280;
      font-weight: 500;
    }
    
    .node-type {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      margin-bottom: 8px;
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      cursor: move;
      transition: all 0.2s;
    }
    
    .node-type:hover {
      border-color: #3b82f6;
      transform: translateX(2px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .node-type.dragging {
      opacity: 0.5;
    }
    
    .node-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      font-size: 20px;
    }
    
    /* Node type specific colors */
    .node-type.process .node-icon { background: #3b82f6; color: white; }
    .node-type.decision .node-icon { background: #f59e0b; color: white; }
    .node-type.data .node-icon { background: #10b981; color: white; }
    .node-type.terminal .node-icon { background: #6366f1; color: white; }
    .node-type.document .node-icon { background: #8b5cf6; color: white; }
    .node-type.database .node-icon { background: #ef4444; color: white; }
    
    .node-info {
      flex: 1;
    }
    
    .node-info h4 {
      margin: 0 0 2px 0;
      font-size: 14px;
      font-weight: 600;
    }
    
    .node-info p {
      margin: 0;
      font-size: 12px;
      color: #6b7280;
    }
    
    /* Controls */
    button {
      padding: 6px 12px;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }
    
    button:hover:not(:disabled) {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    button.primary {
      background: #3b82f6;
      color: white;
      border-color: #2563eb;
    }
    
    button.primary:hover:not(:disabled) {
      background: #2563eb;
    }
    
    select {
      padding: 6px 10px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 13px;
      background: white;
    }
    
    .status-bar {
      display: flex;
      justify-content: space-between;
      padding: 8px 15px;
      background: #f9fafb;
      border-top: 1px solid #e5e7eb;
      font-size: 12px;
      color: #6b7280;
    }
    
    .graph-editor {
      width: 100%;
      height: 100%;
    }
    
    /* Custom node rendering in graph */
    .graph-editor svg {
      background: white;
    }
    
    /* Drag ghost */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      opacity: 0.8;
      z-index: 1000;
      transform: translate(-50%, -50%);
    }
    
    /* Properties panel */
    .properties-panel {
      padding: 15px;
      border-top: 1px solid #e5e7eb;
    }
    
    .properties-panel h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      text-transform: uppercase;
      color: #6b7280;
      font-weight: 500;
    }
    
    .property {
      margin-bottom: 10px;
    }
    
    .property label {
      display: block;
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 4px;
    }
    
    .property input,
    .property select {
      width: 100%;
      padding: 6px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 13px;
    }
    
    .no-selection {
      text-align: center;
      color: #9ca3af;
      font-size: 13px;
      padding: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Node Types Customization Demo</h1>
      <p>Drag different node types from the palette to create a customized graph</p>
    </div>
    
    <div class="main-layout">
      <div class="sidebar">
        <div class="node-palette">
          <h3>Node Types</h3>
          
          <div class="node-type process" draggable="true" data-node-type="process">
            <div class="node-icon">‚ñ°</div>
            <div class="node-info">
              <h4>Process</h4>
              <p>Standard process step</p>
            </div>
          </div>
          
          <div class="node-type decision" draggable="true" data-node-type="decision">
            <div class="node-icon">‚óá</div>
            <div class="node-info">
              <h4>Decision</h4>
              <p>Conditional branch</p>
            </div>
          </div>
          
          <div class="node-type data" draggable="true" data-node-type="data">
            <div class="node-icon">‚ñ±</div>
            <div class="node-info">
              <h4>Data</h4>
              <p>Input/Output data</p>
            </div>
          </div>
          
          <div class="node-type terminal" draggable="true" data-node-type="terminal">
            <div class="node-icon">‚óè</div>
            <div class="node-info">
              <h4>Terminal</h4>
              <p>Start/End point</p>
            </div>
          </div>
          
          <div class="node-type document" draggable="true" data-node-type="document">
            <div class="node-icon">üìÑ</div>
            <div class="node-info">
              <h4>Document</h4>
              <p>Document or report</p>
            </div>
          </div>
          
          <div class="node-type database" draggable="true" data-node-type="database">
            <div class="node-icon">üóÑÔ∏è</div>
            <div class="node-info">
              <h4>Database</h4>
              <p>Data storage</p>
            </div>
          </div>
        </div>
        
        <div class="properties-panel">
          <h3>Properties</h3>
          <div id="propertiesContent" class="no-selection">
            Select a node to edit properties
          </div>
        </div>
      </div>
      
      <div class="content">
        <div class="toolbar">
          <button id="selectBtn" class="primary">Select</button>
          <button id="connectBtn">Connect</button>
          <span style="width: 1px; height: 20px; background: #e5e7eb; margin: 0 5px;"></span>
          <button id="deleteBtn" disabled>Delete</button>
          <button id="undoBtn" disabled>Undo</button>
          <button id="redoBtn" disabled>Redo</button>
          <span style="width: 1px; height: 20px; background: #e5e7eb; margin: 0 5px;"></span>
          <button id="autoLayoutBtn">Auto Layout</button>
          <button id="exportBtn">Export JSON</button>
          <span style="flex: 1;"></span>
          <select id="rendererSelect">
            <option value="svg">SVG Renderer</option>
            <option value="canvas">Canvas Renderer</option>
          </select>
        </div>
        
        <div class="editor-container" id="editorContainer"></div>
        
        <div class="status-bar">
          <span>Nodes: <strong id="nodeCount">0</strong> | Edges: <strong id="edgeCount">0</strong></span>
          <span>Tool: <strong id="currentTool">select</strong></span>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { GraphEditor } from '/src/components/graph-editor/index.js';
    import { SelectTool } from '/src/components/graph-editor/tools/SelectTool.js';
    import { ConnectTool } from '/src/components/graph-editor/tools/ConnectTool.js';
    
    // Node type definitions
    const nodeTypes = {
      process: {
        shape: 'rectangle',
        color: '#3b82f6',
        icon: '‚ñ°',
        defaultSize: { width: 120, height: 60 }
      },
      decision: {
        shape: 'diamond',
        color: '#f59e0b',
        icon: '‚óá',
        defaultSize: { width: 100, height: 100 }
      },
      data: {
        shape: 'parallelogram',
        color: '#10b981',
        icon: '‚ñ±',
        defaultSize: { width: 120, height: 60 }
      },
      terminal: {
        shape: 'ellipse',
        color: '#6366f1',
        icon: '‚óè',
        defaultSize: { width: 100, height: 50 }
      },
      document: {
        shape: 'rectangle',
        color: '#8b5cf6',
        icon: 'üìÑ',
        defaultSize: { width: 100, height: 80 }
      },
      database: {
        shape: 'cylinder',
        color: '#ef4444',
        icon: 'üóÑÔ∏è',
        defaultSize: { width: 80, height: 100 }
      }
    };
    
    // Initialize editor
    let editor = null;
    let nodeIdCounter = 1;
    let selectedNodeId = null;
    
    function createEditor() {
      const container = document.getElementById('editorContainer');
      
      editor = GraphEditor.create({
        dom: container,
        onModelChange: (type, data) => {
          updateStatus();
          
          // Handle selection changes for properties panel
          if (type === 'selectionChanged') {
            updatePropertiesPanel();
          }
        },
        onSelectionChange: (selection) => {
          selectedNodeId = selection.length === 1 ? selection[0] : null;
          updatePropertiesPanel();
          updateToolbarState();
        },
        onHistoryChange: () => {
          updateToolbarState();
        },
        onMount: (instance) => {
          setupTools();
          setupCustomRendering();
          createInitialGraph();
          updateStatus();
        }
      });
    }
    
    // Setup tools
    function setupTools() {
      const coordinator = editor.getViewModel().getEventCoordinator();
      
      coordinator.registerTool('select', new SelectTool());
      coordinator.registerTool('connect', new ConnectTool());
      coordinator.setActiveTool('select');
    }
    
    // Custom node rendering based on type
    function setupCustomRendering() {
      const view = editor.getView();
      const originalRender = view.render.bind(view);
      
      // Override render to customize node appearance
      view.render = function() {
        originalRender();
        
        // Customize SVG nodes based on type
        if (view.getRendererType() === 'svg') {
          const svg = view.getContainer().querySelector('svg');
          const nodes = editor.getModel().getSceneGraph().getAllNodes();
          
          nodes.forEach(node => {
            if (node.getId() === 'root') return;
            
            const nodeData = node.getData() || {};
            const nodeType = nodeData.type || 'process';
            const typeConfig = nodeTypes[nodeType];
            
            if (typeConfig) {
              const nodeEl = svg.querySelector(`[data-node-id="${node.getId()}"]`);
              if (nodeEl) {
                // Update shape
                const rect = nodeEl.querySelector('rect');
                if (rect) {
                  rect.setAttribute('fill', typeConfig.color);
                  rect.setAttribute('rx', nodeType === 'terminal' ? '25' : '4');
                  
                  // Add shape-specific styling
                  if (nodeType === 'decision') {
                    // Transform to diamond
                    const cx = parseFloat(rect.getAttribute('x')) + parseFloat(rect.getAttribute('width')) / 2;
                    const cy = parseFloat(rect.getAttribute('y')) + parseFloat(rect.getAttribute('height')) / 2;
                    rect.setAttribute('transform', `rotate(45 ${cx} ${cy})`);
                  }
                }
                
                // Add icon if not present
                let icon = nodeEl.querySelector('.node-icon');
                if (!icon && typeConfig.icon) {
                  const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                  text.setAttribute('class', 'node-icon');
                  text.setAttribute('x', parseFloat(rect.getAttribute('x')) + parseFloat(rect.getAttribute('width')) / 2);
                  text.setAttribute('y', parseFloat(rect.getAttribute('y')) + 20);
                  text.setAttribute('text-anchor', 'middle');
                  text.setAttribute('font-size', '20');
                  text.setAttribute('fill', 'white');
                  text.setAttribute('pointer-events', 'none');
                  text.textContent = typeConfig.icon;
                  nodeEl.appendChild(text);
                }
              }
            }
          });
        }
      };
    }
    
    // Create initial demo graph
    function createInitialGraph() {
      const model = editor.getModel();
      
      // Start node
      const startNode = model.addNode({
        id: 'start',
        position: { x: 100, y: 50 },
        label: 'Start',
        size: { width: 100, height: 50 },
        data: { type: 'terminal' }
      });
      
      // Process node
      const processNode = model.addNode({
        id: 'process1',
        position: { x: 250, y: 50 },
        label: 'Process Data',
        size: { width: 120, height: 60 },
        data: { type: 'process' }
      });
      
      // Decision node
      const decisionNode = model.addNode({
        id: 'decision1',
        position: { x: 400, y: 50 },
        label: 'Valid?',
        size: { width: 100, height: 100 },
        data: { type: 'decision' }
      });
      
      // Data nodes
      const dataNode1 = model.addNode({
        id: 'data1',
        position: { x: 300, y: 200 },
        label: 'Error Log',
        size: { width: 120, height: 60 },
        data: { type: 'data' }
      });
      
      const dataNode2 = model.addNode({
        id: 'data2',
        position: { x: 500, y: 200 },
        label: 'Results',
        size: { width: 120, height: 60 },
        data: { type: 'data' }
      });
      
      // Connect nodes
      model.addEdge({ source: 'start', target: 'process1' });
      model.addEdge({ source: 'process1', target: 'decision1' });
      model.addEdge({ source: 'decision1', target: 'data1', label: 'No' });
      model.addEdge({ source: 'decision1', target: 'data2', label: 'Yes' });
    }
    
    // Handle drag and drop
    function setupDragAndDrop() {
      const nodeTypes = document.querySelectorAll('.node-type');
      let dragGhost = null;
      
      nodeTypes.forEach(nodeTypeEl => {
        nodeTypeEl.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'copy';
          e.dataTransfer.setData('nodeType', nodeTypeEl.dataset.nodeType);
          nodeTypeEl.classList.add('dragging');
          
          // Create custom drag image
          dragGhost = nodeTypeEl.cloneNode(true);
          dragGhost.classList.add('drag-ghost');
          document.body.appendChild(dragGhost);
          e.dataTransfer.setDragImage(dragGhost, 50, 25);
        });
        
        nodeTypeEl.addEventListener('dragend', () => {
          nodeTypeEl.classList.remove('dragging');
          if (dragGhost) {
            dragGhost.remove();
            dragGhost = null;
          }
        });
      });
      
      const editorContainer = document.getElementById('editorContainer');
      
      editorContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
      });
      
      editorContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        
        const nodeType = e.dataTransfer.getData('nodeType');
        if (!nodeType) return;
        
        const typeConfig = nodeTypes[nodeType];
        const rect = editorContainer.getBoundingClientRect();
        
        // Calculate position in graph coordinates
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Create new node
        const nodeData = {
          id: `node${nodeIdCounter++}`,
          position: { x, y },
          label: `${nodeType.charAt(0).toUpperCase() + nodeType.slice(1)} ${nodeIdCounter}`,
          size: typeConfig.defaultSize,
          data: { type: nodeType }
        };
        
        editor.getViewModel().executeCommandType('addNode', { nodeData });
      });
    }
    
    // Update status bar
    function updateStatus() {
      if (!editor) return;
      
      const model = editor.getModel();
      const nodes = model.getSceneGraph().getAllNodes().filter(n => n.getId() !== 'root');
      const edges = model.getEdges();
      
      document.getElementById('nodeCount').textContent = nodes.length;
      document.getElementById('edgeCount').textContent = edges.length;
      document.getElementById('currentTool').textContent = 
        editor.getViewModel().getEventCoordinator().getActiveTool();
    }
    
    // Update toolbar state
    function updateToolbarState() {
      if (!editor) return;
      
      const viewModel = editor.getViewModel();
      const hasSelection = viewModel.getSelection().length > 0;
      
      document.getElementById('deleteBtn').disabled = !hasSelection;
      document.getElementById('undoBtn').disabled = !viewModel.canUndo();
      document.getElementById('redoBtn').disabled = !viewModel.canRedo();
    }
    
    // Update properties panel
    function updatePropertiesPanel() {
      const propertiesContent = document.getElementById('propertiesContent');
      
      if (!selectedNodeId || !editor) {
        propertiesContent.innerHTML = '<div class="no-selection">Select a node to edit properties</div>';
        return;
      }
      
      const node = editor.getModel().getSceneGraph().getNodeById(selectedNodeId);
      if (!node) return;
      
      const nodeData = node.getData() || {};
      const nodeType = nodeData.type || 'process';
      
      propertiesContent.innerHTML = `
        <div class="property">
          <label>ID</label>
          <input type="text" value="${node.getId()}" disabled>
        </div>
        <div class="property">
          <label>Label</label>
          <input type="text" id="nodeLabel" value="${node.getLabel() || ''}">
        </div>
        <div class="property">
          <label>Type</label>
          <select id="nodeType">
            ${Object.keys(nodeTypes).map(type => 
              `<option value="${type}" ${type === nodeType ? 'selected' : ''}>${type.charAt(0).toUpperCase() + type.slice(1)}</option>`
            ).join('')}
          </select>
        </div>
        <div class="property">
          <label>X Position</label>
          <input type="number" id="nodeX" value="${Math.round(node.getPosition().x)}">
        </div>
        <div class="property">
          <label>Y Position</label>
          <input type="number" id="nodeY" value="${Math.round(node.getPosition().y)}">
        </div>
      `;
      
      // Add event listeners
      document.getElementById('nodeLabel').addEventListener('input', (e) => {
        node.setLabel(e.target.value);
        editor.getView().render();
      });
      
      document.getElementById('nodeType').addEventListener('change', (e) => {
        const newType = e.target.value;
        const newData = { ...nodeData, type: newType };
        node.setData(newData);
        
        // Update size based on type
        const typeConfig = nodeTypes[newType];
        if (typeConfig && typeConfig.defaultSize) {
          node.setSize(typeConfig.defaultSize.width, typeConfig.defaultSize.height);
        }
        
        editor.getView().render();
      });
      
      document.getElementById('nodeX').addEventListener('input', (e) => {
        const x = parseFloat(e.target.value);
        if (!isNaN(x)) {
          node.setPosition(x, node.getPosition().y);
          editor.getView().render();
        }
      });
      
      document.getElementById('nodeY').addEventListener('input', (e) => {
        const y = parseFloat(e.target.value);
        if (!isNaN(y)) {
          node.setPosition(node.getPosition().x, y);
          editor.getView().render();
        }
      });
    }
    
    // Tool buttons
    document.getElementById('selectBtn').addEventListener('click', () => {
      editor.getViewModel().getEventCoordinator().setActiveTool('select');
      document.getElementById('selectBtn').classList.add('primary');
      document.getElementById('connectBtn').classList.remove('primary');
      updateStatus();
    });
    
    document.getElementById('connectBtn').addEventListener('click', () => {
      editor.getViewModel().getEventCoordinator().setActiveTool('connect');
      document.getElementById('connectBtn').classList.add('primary');
      document.getElementById('selectBtn').classList.remove('primary');
      updateStatus();
    });
    
    document.getElementById('deleteBtn').addEventListener('click', () => {
      const selection = editor.getViewModel().getSelection();
      selection.forEach(nodeId => {
        editor.getViewModel().executeCommandType('removeNode', { nodeId });
      });
    });
    
    document.getElementById('undoBtn').addEventListener('click', () => {
      editor.getViewModel().undo();
    });
    
    document.getElementById('redoBtn').addEventListener('click', () => {
      editor.getViewModel().redo();
    });
    
    document.getElementById('autoLayoutBtn').addEventListener('click', () => {
      editor.getViewModel().applyLayout('dagre');
    });
    
    document.getElementById('exportBtn').addEventListener('click', () => {
      const data = editor.getModel().toJSON();
      const json = JSON.stringify(data, null, 2);
      
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'graph-export.json';
      a.click();
      URL.revokeObjectURL(url);
    });
    
    document.getElementById('rendererSelect').addEventListener('change', async (e) => {
      await editor.getView().setRendererType(e.target.value);
      setupCustomRendering(); // Re-apply custom rendering
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (!editor) return;
      
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        editor.getViewModel().undo();
      }
      
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        editor.getViewModel().redo();
      }
      
      if (e.key === 'Delete') {
        const selection = editor.getViewModel().getSelection();
        selection.forEach(nodeId => {
          editor.getViewModel().executeCommandType('removeNode', { nodeId });
        });
      }
    });
    
    // Initialize
    createEditor();
    setupDragAndDrop();
  </script>
</body>
</html>